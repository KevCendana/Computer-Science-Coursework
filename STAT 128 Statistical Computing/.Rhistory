# Extract the first digit of each price
first_digits <- substr(diamonds$price, 1, 1)
# Convert the first digits to numeric
first_digits <- as.numeric(first_digits)
# Perform Benford's Law analysis
benford_result <- benford(first_digits, number.of.digits = 1)
# Plot the result
plot(benford_result)
install.packages("ggplot2")
install.packages("ggplot2")
library(tidyverse)
# Load the diamonds dataset
data(diamonds)
# Extract the first digit of each price
first_digits <- substr(diamonds$price, 1, 1)
# Convert the first digits to numeric
first_digits <- as.numeric(first_digits)
# Perform Benford's Law analysis
benford_result <- benford(first_digits, number.of.digits = 1)
install.packages("ggplot2")
install.packages("ggplot2")
library(tidyverse)
# Install necessary packages
install.packages("ggplot2")
install.packages("benford.analysis")
# Load necessary packages
library(ggplot2)
library(benford.analysis)
# Load the diamonds dataset
data(diamonds)
# Extract the first digit of each price
first_digits <- substr(diamonds$price, 1, 1)
# Convert the first digits to numeric
first_digits <- as.numeric(first_digits)
# Perform Benford's Law analysis
benford_result <- benford(first_digits, number.of.digits = 1)
install.packages("ggplot2")
# Plot the result
plot(benford_result)
library(tidyverse)
data(diamonds)
# Next, you need to extract the first digit from the price column. We will use the substr function to do this:
diamonds$first_digit <- substr(diamonds$price, 1, 1)
# Then, calculate the frequency of each first digit:
first_digit_freq <- diamonds %>%
group_by(first_digit) %>%
summarise(count = n()) %>%
mutate(freq = count / sum(count))
# Now, you can plot the frequency of each first digit:
ggplot(first_digit_freq, aes(x = first_digit, y = freq)) +
geom_bar(stat = "identity") +
labs(x = "First Digit", y = "Frequency",
title = "Distribution of First Digits in Diamond Prices")
library(tidyverse)
# Load necessary packages
library(ggplot2)
library(benford.analysis)
# Load the diamonds dataset
data(diamonds)
# Extract the first digit of each price
first_digits <- substr(diamonds$price, 1, 1)
# Convert the first digits to numeric
first_digits <- as.numeric(first_digits)
# Perform Benford's Law analysis
benford_result <- benford(first_digits, number.of.digits = 1)
# Plot the result
plot(benford_result)
library(tidyverse)
library(benford.analysis) # https://www.rdocumentation.org/packages/benford.analysis/versions/0.1.5
# Load the diamonds dataset
data(diamonds)
# Extract the first digit of each price
first_digits <- substr(diamonds$price, 1, 1)
# Convert the first digits to numeric
first_digits <- as.numeric(first_digits)
# Perform Benford's Law analysis
benford_result <- benford(first_digits, number.of.digits = 1)
# Plot the result
plot(benford_result)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_digits <- substr(diamonds$price, 1, 1)
# convert to numeric (required for benford analysis) then calculate freq
first_digits <- as.numeric(first_digits)
benford_result <- benford(first_digits, number.of.digits = 1)
# plot
plot(benford_result)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to numeric (required for benford analysis) then calculate freq
first_num <- as.numeric(first_digits)
benford_analysis<- benford(first_digits, number.of.digits = 1)
# plot
plot(benford_analysis)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to numeric (required for benford analysis) then calculate freq
first_num <- first_num
benford_analysis<- benford(first_num, number.of.digits = 1)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num, number.of.digits = 1)
# plot
plot(benford_analysis)
# Example of S3
dd <- data.frame(a = rnorm(100), b = rnorm(100))
# Example of S3
dd <- data.frame(a = rnorm(100), b = rnorm(100))
class(dd)
# Example of S3
# make df
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# The class of the dd object is "data.frame"
class(dd)
# Printing the data frame
print(dd)
# Example of S3
# make df
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# The class of the dd object is "data.frame"
class(dd)
# Printing the data frame
print(dd)
# Load the utils package
library(utils)
# Use the print.packageIQR function
print.packageIQR(dd)
library(utils)
# Example of S3
# make df
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# The class of the dd object is "data.frame"
class(dd)
# Printing the data frame
print(dd)
# Load the utils package
library(utils)
# Use the print.packageIQR function
print.packageIQR(dd)
# Example of S3
# make df
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# show that dd is a dataframe type object
class(dd)
print(dd)
# Load the utils package
library(utils)
# Use the print.packageIQR function
print.packageIQR(dd)
# Example of S3
# make df
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# show that dd is a dataframe type object
class(dd)
print(dd)
sapply(dd, IQR, na.rm=TRUE)
# Example of S3
# make df
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
nex = c("M", "M", "F"))
# show that dd is a dataframe type object
class(dd)
print(dd)
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"))
# show that dd is a dataframe type object
class(dd)
print(dd)
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
sex = c("M", "M", "F"))
# show that dd is a dataframe type object
class(dd)
print(dd)
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
sex = c("M", "M", "F"))
# they are two different types...
class(dd)
print(dd)
# ... but sapply still works!
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
sex = c("M", "M", "F"))
# they are two different types...
class(dd)
class(x)
# ... but sapply still works :]
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
sex = c("M", "M", "F"))
# they are two different types...
class(dd)
class(x)
# ... but sapply doesn't cause an error by taking in an invalid argument
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
# extract data
d2 <- data()[["results"]][["Item"]]
d <- data() |>
getElement("results") |>
data.frame() |>
getElement("Item")
head(d)
d <- data() |>
getElement("results") |>
data.frame() |>
getElement("Item")
head(d)
# extract data
d2 <- data()[["results"]][["Item"]]
# Using [[ rather than getElement
# Using only nested function calls rather than a pipe
# Saving the result to d2 rather than d
d2 <- head(data.frame(data()[["results"]][["Item"]]))
check_dataframe <- function(df) {
# Check if the object is a data frame
if (class(df) != "data.frame") {
return(FALSE)
}
# Check if there are any numeric columns
for (col in colnames(df)) {
if (class(df[[col]]) == "numeric") {
return(TRUE)
}
}
# If there are no numeric columns, return FALSE
return(FALSE)
}
# Testing the function
t1 <- data.frame(a = 100, b = "hi")
print(check_dataframe(t1)) # should return TRUE
t2 <- as.list(t1)
print(check_dataframe(t2)) # should return FALSE
t3 <- data.frame(b = "only strings")
print(check_dataframe(t3)) # should return FALSE
check_dataframe <- function(df) {
# check if the object is a data frame
if (class(df) != "data.frame") {
return(FALSE)
}
# check if there are any numeric columns
for (col in colnames(df)) {
if (class(df[[col]]) == "numeric") {
return(TRUE)
}
}
# if there are no numeric columns, not a df
return(FALSE)
}
# return TRUE
t1 <- data.frame(a = 100, b = "hi")
print(check_dataframe(t1)) # should return TRUE
# return FALSE - it's a list, not a data frame
t2 <- as.list(t1)
print(check_dataframe(t2)) # should return FALSE
# return FALSE - no numeric columns
t3 <- data.frame(b = "only strings")
print(check_dataframe(t3)) # should return FALSE
check_dataframe <- function(df) {
# check if the object is a data frame
if (class(df) = "data.frame") {
check_dataframe <- function(df) {
# check if the object is a data frame
if (class(df) != "data.frame") {
return(FALSE)
}
# check if there are any numeric columns
for (col in colnames(df)) {
if (class(df[[col]]) == "numeric") {
return(TRUE)
}
}
# if there are no numeric columns, not a df
return(FALSE)
}
# data
digits <- (1+1/9)
pd = log10(digits)
# plot
plot((digits), pd, xlab = "Digits", ylab = "P(d)", main = "p(d) vs. digits")
benford <- function(x){
expected <- log10(1 + 1 / (1:9))
fd <- substr(gsub('[0.]', '', x), 1, 1)
fd <- factor(fd, levels = 1:9)
actual <- table(fd) / length(x)
1 - sum(abs(actual - expected))
}
# data
digits <- (1:9)
pd = log10(digits)
# plot
plot((digits), pd, xlab = "Digits", ylab = "P(d)", main = "p(d) vs. digits")
x <- 10^(runif(1000, min = 0, max = 3))
x <- rep(9, 1000)
benford <- function(x){
expected <- log10(1 + 1 / (1:9))
fd <- substr(gsub('[0.]', '', x), 1, 1)
fd <- factor(fd, levels = 1:9)
actual <- table(fd) / length(x)
1 - sum(abs(actual - expected))
}
x <- 10^(runif(1000, min = 0, max = 3))
x <- rep(9, 1000)
benford <- function(x){
expected <- log10(1 + 1 / (1:9))
fd <- substr(gsub('[0.]', '', x), 1, 1)
fd <- factor(fd, levels = 1:9)
actual <- table(fd) / length(x)
1 - sum(abs(actual - expected))
}
x <- 10^(runif(1000, min = 0, max = 3))
x <- rep(9, 1000)
# ex for 2.
c(1, 10, 100, 1000, 10000) # close to 1
c(9, 90, 900, 9000, 90000) # close to -1
benford <- function(x){
expected <- log10(1 + 1 / (1:9))
fd <- substr(gsub('[0.]', '', x), 1, 1)
fd <- factor(fd, levels = 1:9)
actual <- table(fd) / length(x)
1 - sum(abs(actual - expected))
}
# ex for 2.
c(1, 10, 100, 1000, 10000) # close to 1
c(9, 90, 900, 9000, 90000) # close to -1
d2 <- head(data.frame(data()[["results"]][["Item"]]))
pts <- c(2, 3, 4, 5, 3, 3, 4, 3, 2)
paste("total points possible:", sum(pts))
library(tidyverse)
# data
p2 = log10(1+1/2)
p7 = log10(1+1/7)
# how many times 2 occurs vs. 7
print(p2/p7)
# data
digits <- (1:9)
pd = log10(digits)
# plot
plot((digits), pd, xlab = "Digits", ylab = "P(d)", main = "p(d) vs. digits")
# original
# first_digit <- function(x) substr(gsub('[0.]', '', x), 1, 1)
# new version
first_digit <- function(x) {
as.integer(substr(sub("^0+","",as.character(x)), 1, 1))
}
# original
# fd_proportion <- function(x) data.frame(table(first_digit(x)) / length(x))
# cooler version (i hope)
fd_proportion <- function(x) {
# calculate relative frequencies & return dataframe
relative_frequencies <- table(first_digit(x))/length(x)
data.frame('first_digit' = names(relative_frequencies),
'benford_prop' = relative_frequencies)
}
# testing first_digit
print(first_digit(123))  # should be "1"
print(first_digit(56))  # should be "5"
print(first_digit(0.0123))  # should be "1"
# testing fd_proportion
print(fd_proportion(c(135, 468, 246, 0.123)))  # should be .25
print(fd_proportion(c(123, 456, 789, 0.123)))  # should be .25
print(fd_proportion(c(158, 470, 257, 0.123)))  # should be .25
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num, number.of.digits = 1)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num, number.of.digits = 1)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num, number.of.digits = 1)
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num)
# plot (kinda extra but i'm too far in)
plot(benford_analysis)
# d2 <- head(data.frame(data()[["results"]][["Item"]])) ???
# :(
pts <- c(2, 3, 4, 5, 3, 3, 4, 3, 2)
paste("total points possible:", sum(pts))
# data
p2 = log10(1+1/2)
p7 = log10(1+1/7)
# how many times 2 occurs vs. 7
print(p2/p7)
# data
digits <- (1:9)
pd = log10(digits)
# plot
plot((digits), pd, xlab = "Digits", ylab = "P(d)", main = "p(d) vs. digits")
# original
# first_digit <- function(x) substr(gsub('[0.]', '', x), 1, 1)
# new version
first_digit <- function(x) {
as.integer(substr(sub("^0+","",as.character(x)), 1, 1))
}
# original
# fd_proportion <- function(x) data.frame(table(first_digit(x)) / length(x))
# cooler version (i hope)
fd_proportion <- function(x) {
# calculate relative frequencies & return dataframe
relative_frequencies <- table(first_digit(x))/length(x)
data.frame('first_digit' = names(relative_frequencies),
'benford_prop' = relative_frequencies)
}
# testing first_digit
print(first_digit(123))  # should be "1"
print(first_digit(56))  # should be "5"
print(first_digit(0.0123))  # should be "1"
# testing fd_proportion
print(fd_proportion(c(135, 468, 246, 0.123)))  # should be .25
print(fd_proportion(c(123, 456, 789, 0.123)))  # should be .25
print(fd_proportion(c(158, 470, 257, 0.123)))  # should be .25
library(benford.analysis) # fancy benford's law library
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num, number.of.digits = 1)
library(benford.analysis)
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num)
# plot (kinda extra but i'm too far in)
plot(benford_analysis)
# Example of S3
# make two objects of different types
x <- c(10,20,30)
dd <- data.frame(name = c("Bob", "Bobby", "Bob-ette"),
sex = c("M", "M", "F"))
# they are two different types...
class(dd)
class(x)
# ... but sapply doesn't cause an error by taking in an invalid argument
sapply(dd, IQR, na.rm=TRUE)
sapply(x, IQR, na.rm=TRUE)
d <- data() |>
getElement("results") |>
data.frame() |>
getElement("Item")
head(d)
library(benford.analysis)
library(diamonds)
library(tidyverse)
library(benford.analysis)
library(diamonds)
library(tidyverse)
library(benford.analysis)
# load data & get 1st num from price column
data(diamonds)
first_num <- substr(diamonds$price, 1, 1) # use substr to extract
# convert to proper data type for package then calculate freq
first_num <- as.numeric(first_num) # has to be numeric for function
benford_analysis<- benford(first_num)
# plot (kinda extra but i'm too far in)
plot(benford_analysis)
